// GPU Shader for Video Processing
// Applies pixelation, dithering, palette mapping, and LCD-style grid
// Compatible with GpuVideoPipeline


uniform shader inputFrame;      // Input video frame
uniform float2 res;             // Video resolution (e.g., 1080.0, 1920.0)
uniform float scaleFactor;      // Pixelation scale
uniform float gridIntensity;    // Strength of the LCD grid effect
uniform float gridSize;         // Size of the grid blocks
uniform float ditheringStrength;// Strength of Bayer dithering

// Dynamic color palette
uniform half4 palette0;
uniform half4 palette1;
uniform half4 palette2;
uniform half4 palette3;

// Precomputed Bayer matrix for dithering performance (GPU)
// Const array Bayer



//Compile-safe int version !
float getBayerValue(int x, int y) {
    int ix = int(mod(float(x), 4.0));
    int iy = int(mod(float(y), 4.0));

    // Inline “switch” version safe pour AGSL
    int index = iy * 4 + ix;
    if (index == 0) return 0.0/16.0;
    if (index == 1) return 8.0/16.0;
    if (index == 2) return 2.0/16.0;
    if (index == 3) return 10.0/16.0;
    if (index == 4) return 12.0/16.0;
    if (index == 5) return 4.0/16.0;
    if (index == 6) return 14.0/16.0;
    if (index == 7) return 6.0/16.0;
    if (index == 8) return 3.0/16.0;
    if (index == 9) return 11.0/16.0;
    if (index == 10) return 1.0/16.0;
    if (index == 11) return 9.0/16.0;
    if (index == 12) return 15.0/16.0;
    if (index == 13) return 7.0/16.0;
    if (index == 14) return 13.0/16.0;
    return 5.0/16.0;
}





// Returns the color from the palette based on index
half4 getPaletteColor(int index) {
    if (index == 0) return palette0;
    if (index == 1) return palette1;
    if (index == 2) return palette2;
    return palette3;
}

// Main shader function
half4 main(float2 fragCoord) {
    // 1. PIXELATION 1:1
    // Compute the top-left corner of the "large pixel"
    float2 pixelatedCoord = floor(fragCoord / scaleFactor) * scaleFactor;

    // Sample at the center of the large pixel for temporal stability
    half4 color = inputFrame.eval(pixelatedCoord + (scaleFactor * 0.5));

    // 2. LUMINANCE & DITHERING
    // Standard Rec. 709 luminance calculation
    float luma = dot(color.rgb, half3(0.2126, 0.7152, 0.0722));

    // Bayer matrix coordinates
    int x = int(fragCoord.x / scaleFactor);
    int y = int(fragCoord.y / scaleFactor);

    // Apply dithering on a perceptual curve (gamma 0.8)
    float perceptual = pow(luma, 0.8);
    float dither = perceptual + (getBayerValue(x, y) - 0.5) * ditheringStrength;

    // 3. PALETTE INDEXING
    // The +0.08 is a bias to adjust dark tone thresholds
    int paletteIdx = int(clamp(dither * 4.0 + 0.08, 0.0, 3.99));
    half4 finalColor = getPaletteColor(paletteIdx);

    // 4. LCD GRID (based on fragCoord to remain fixed relative to output pixels)
    float2 gridPos = mod(fragCoord, gridSize);
    float grid = step(gridPos.y, gridSize * 0.15) + step(gridPos.x, gridSize * 0.15);

    // Apply the grid effect
    finalColor.rgb *= (1.0 - clamp(grid, 0.0, 1.0) * gridIntensity);

    // Force alpha to 1.0 for video encoder compatibility
    return half4(finalColor.rgb, 1.0);
}