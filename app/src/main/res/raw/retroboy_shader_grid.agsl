// RetroBoy Shader - AGSL Android (API 33+) with LCD Grid

uniform shader inputFrame;
uniform float scaleFactor; // 4.0 to 48.0
uniform float gridIntensity; // 0.0 to 1.0 (recommended: 0.12)
uniform float gridSize; // 1.0 to 4.0 (pixel grid size)

// Game Boy Palette (4 authentic green tones)
const float4 palette0 = float4(0.06, 0.22, 0.12, 1.0);  // #0F381F
const float4 palette1 = float4(0.19, 0.38, 0.19, 1.0);  // #306230
const float4 palette2 = float4(0.48, 0.67, 0.49, 1.0);  // #7BAC7D
const float4 palette3 = float4(0.68, 0.85, 0.68, 1.0);  // #AED9AE

// Bayer 4x4 Matrix for ordered dithering
float getBayerValue(int x, int y) {
    int ix = x % 4;
    int iy = y % 4;

    // Row 0
    if (iy == 0 && ix == 0) return 0.0/16.0;
    if (iy == 0 && ix == 1) return 8.0/16.0;
    if (iy == 0 && ix == 2) return 2.0/16.0;
    if (iy == 0 && ix == 3) return 10.0/16.0;

    // Row 1
    if (iy == 1 && ix == 0) return 12.0/16.0;
    if (iy == 1 && ix == 1) return 4.0/16.0;
    if (iy == 1 && ix == 2) return 14.0/16.0;
    if (iy == 1 && ix == 3) return 6.0/16.0;

    // Row 2
    if (iy == 2 && ix == 0) return 3.0/16.0;
    if (iy == 2 && ix == 1) return 11.0/16.0;
    if (iy == 2 && ix == 2) return 1.0/16.0;
    if (iy == 2 && ix == 3) return 9.0/16.0;

    // Row 3
    if (iy == 3 && ix == 0) return 15.0/16.0;
    if (iy == 3 && ix == 1) return 7.0/16.0;
    if (iy == 3 && ix == 2) return 13.0/16.0;
    return 5.0/16.0;
}

float4 getPaletteColor(int index) {
    if (index == 0) return palette0;
    if (index == 1) return palette1;
    if (index == 2) return palette2;
    return palette3;
}

// Generate LCD grid pattern
float getLCDGrid(float2 coord, float size) {
    // Create a grid pattern based on pixel coordinates
    float2 gridPos = mod(coord, size);

    // Create crosshatch pattern (vertical + horizontal lines)
    float gridLine = 0.0;

    // Horizontal lines
    if (gridPos.y < size * 0.15 || gridPos.y > size * 0.85) {
        gridLine = 1.0;
    }

    // Vertical lines
    if (gridPos.x < size * 0.15 || gridPos.x > size * 0.85) {
        gridLine = 1.0;
    }

    return gridLine;
}

float4 main(float2 fragCoord) {
    // 1. PIXELATION
    float2 pixelSize = float2(scaleFactor, scaleFactor);
    float2 pixelCoord = floor(fragCoord / pixelSize);
    float2 samplingCoord = (pixelCoord + 0.5) * pixelSize;

    // Sample input shader
    float4 color = inputFrame.eval(samplingCoord);

    // 2. LUMINANCE CONVERSION
    float luma = dot(color.rgb, float3(0.299, 0.587, 0.114));

    // 3. BAYER DITHERING
    int x = int(fragCoord.x);
    int y = int(fragCoord.y);
    float threshold = getBayerValue(x, y);

    // Apply dithering bias
    float ditheredLuma = luma + (threshold - 0.5) * 0.25;

    // 4. PALETTE QUANTIZATION
    int paletteIdx = int(clamp(ditheredLuma * 4.0, 0.0, 3.999));
    float4 finalColor = getPaletteColor(paletteIdx);

    // 5. LCD GRID OVERLAY
    float grid = getLCDGrid(fragCoord, gridSize);

    // Apply grid: darken where grid lines are present
    finalColor.rgb = finalColor.rgb * (1.0 - grid * gridIntensity);

    // Alternative: brighten grid lines instead (uncomment if preferred)
    // finalColor.rgb = finalColor.rgb * (1.0 + grid * gridIntensity);

    return finalColor;
}